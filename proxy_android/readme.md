这是Android版本的proxy

其目的是安装到某个硬件上，放置于小车中，实现小车的代理，通过这个代理连接云服务器，云服务器就是简单的信令双向中转。这样遥控器就可以在任意位置，任意网络下控制小车。




之所以选择Android作为proxy，是因为用openwrt碰到了不少困难，或者说Android有如下优点：

1）体积小，去掉屏幕后只留主板和电池的荣耀8 lite可以做的体积非常小

2）续航时间长，实测荣耀8的2000mAH电池续航一天（开wifi和蜂窝），比小车的续航长不少。自带电池，不占用小车的续航

3）价格足够便宜，目前用的是闲置的荣耀8青春版，某鱼收一个几十块

4）信号好，proxy因为内置于小车中，所以wifi天线要求不高；对蜂窝天线的性能要求高，实测荣耀8的电信信号在换了贴片天线后依旧不强，但也比4G卡托强不少

5）开发环境好，接上屏幕可以用户界面操作，Android可以做一个简单的控制面板，比openwrt要强些；开发编译也方便，蜂窝部分插一张SIM卡就行了，openwrt还要折腾rndis驱动

6）性能强，proxy关键的是要求wifi和蜂窝双连接，在两个网卡间数据转发，Android的性能肯定是够的

7）数据转发的问题，openwrt和Android都可以实现两个socket分别绑定wifi及蜂窝网卡，openwrt需要手动设置default路由，毕竟热点和4G网卡都是默认属于wan口，Android没这问题，socket可以绑定某个具体的某个network，数据收发跟着网卡。


proxy的设计：


第一次开发类似的程序，关键的信息，或者总结

1. 因为小车的业务逻辑：创建socket后需立即发初始化包，否则会断开socket，proxy作为代理，应该是检测到云端转发的login消息后再创建socket

但这样的话，就导致proxy需要关心具体的login信令，出于解耦合的目的，设计成只要收到云端数据包，发送给小车时检查是否"connection reset"错误码，就重连socket

2. Camera的socket一样有这个限制，应该仿照上述实现，但目前的做法是检查了小车返回的信令，主动在proxy侧创建media socket，同时发media的login，造成了业务耦合

3. 出于实现层面简单化，上行流media和command就复用了一个socket，这样relay云的设计会简单些，遥控侧要根据信令流做拆分，也不复杂

4. proxy因为实际运行过程中没有界面操作（屏幕被卸掉了），唯一的用户交互只有一个简单焊接引出开机按钮，应用又收不到power键（Android限制），所以变通的方法就是监听屏幕亮灭事件。
点亮屏幕就发起所有socket的重连，重连前需要关闭之前的socket，确保云端可以检测到socket关闭，触发socket监听进程可以进入到等待客户端重连的状态。

此处，需要说明下，蜂窝网络下，client端socket关闭（应用退出或者主动socket.close）,server端socket不一定立马能检测到。所以在relay侧做了发现有新的客户端连接后，就重新创建一个收发线程，来处理新的客户端消息，不得已而为之。

5. 涉及发送接收的场合，尤其是端口复用，要计算下tcp buffer的大小，避免不必要的数据拆包，会导致媒体头检测不准

6. 数据转发的核心就是在两个socket之间转发数据，所以要等两个socket都连接成功后，再启动转发线程，所以要在每个socket连接成功后，检测下另外一个socket状态，确保转发线程能启动

7. 因为proxy里面也不完全是转发，也有少量的跟小车业务逻辑的交互，所以用端口转发，映射之类的技术应该是搞不定的，所以放弃了openwrt上实现proxy的计划，转战Android

8. Android上面请求蜂窝网络用requestNetwork接口，收到回调后把socket跟具体的Network绑定，dns查询也用Network的接口，就保证了socket数据固定在LTE网卡（modem）上，这点比openwrt友好多了。

9. 实际运行过程发现，芯片发烫，即使没有操作遥控，proxy的转发线程写的应该有效率问题，遗留待分析

10. proxy应该可以检测小车的状态（socket连接，media数据大小等），发送到云端做实时业务面板，或者简单些，控制LED等的状态，遗留待分析可行性
